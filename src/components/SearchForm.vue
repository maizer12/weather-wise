<script>
import { debounce } from 'lodash';
import { geoNames } from '@/_config.js';

export default {
  props: {
    loading: {
      type: Boolean,
      default: false,
    },
    errorCard: {
      type: String,
      default: '',
    },
  },
  data() {
    return {
      searchQuery: '',
      selectedItem: '',
      closeSearch: false,
      autoCompleteResults: [],
      err: '',
    };
  },
  methods: {
    // Красавчик, дебаунс есть
    getAutoCompleteResults: debounce(async function (query) {
      if (query.length < 1) {
        this.autoCompleteResults = [];
        return;
      }
      
      // Используем URL класс для создания урла с параметрами и всем таким - https://www.valentinog.com/blog/url/
      const apiUrl = `https://secure.geonames.org/searchJSON?q=${query}&maxRows=10&username=${geoNames}`;

      try {
        const response = await fetch(apiUrl);
        const { geonames } = await response.json();
        const uniqueCityNames = new Set();
        this.err = '';
        this.autoCompleteResults = geonames.filter((e) => {
          // эта проверка лишняя, ведь у нас уже new Set выше. Можем просто делать this.autoCompleteResults = [...getonames] - и будет массив обычный
          if (e.name.split(' ').length === 1 && !uniqueCityNames.has(e.name)) {
            uniqueCityNames.add(e.name);
            return true;
          }
          return false;
        });
      } catch (error) {
        this.err = 'Sorry, autocomplete is temporarily unavailable, but you can manually enter the city name.';
      }
    }, 500),
    selectCity(elem) {
      this.searchQuery = elem.name + ' , ' + (elem.countryName || elem.name);
      this.selectedItem = elem;
      this.startSearch(this.selectedItem);
    },
    startSearch(ell) {
      // никогда не делаем if в одну строку
      // никогда в return не делаем действий, тут особенно страшно - присваивание
      if (!ell.name) return (this.err = 'Please fill in the required field.');
      this.$emit('search', ell);
    },
    // ну тут можно было эвент сделать типа onClickOutside, есть такой подход, везде используется
    handelBlur() {
      setTimeout(() => {
        this.closeSearch = true;
      }, 300);
    },
  },
  watch: {
    searchQuery(newSearch) {
      // подозрительная строчка, мне кажется это костыль
      this.closeSearch = false;
      this.getAutoCompleteResults(newSearch);
    },
  },
};
</script>

<template>
  <div class="search">
    <p v-if="errorCard.length || err.length" class="error opacity-anim">*{{ errorCard || err }}</p>
    <div class="search__inner">
      <div class="search-form">
        <input-state v-model="searchQuery" @blur="handelBlur" />
        <btn-state @click="startSearch(selectedItem || { name: this.searchQuery })">
          <spinner-loader v-if="loading" /> <template v-else>Search</template>
        </btn-state>
      </div>
      <ul v-if="!!autoCompleteResults.length && !closeSearch" class="search-list">
        <li
          v-for="elem in autoCompleteResults"
          :key="elem.id"
          class="search-list__item"
          @click="selectCity(elem)"
          :class="{ 'active-item': elem.name == selectedItem.name }"
        >
<!--          Используем тройное "===" для консистентности -->
          {{ elem.name }}, {{ elem.countryName || elem.name }}
        </li>
      </ul>
    </div>
  </div>
</template>

<style scoped>
.search {
  margin-bottom: 50px;
  width: fit-content;
}
.search-form {
  display: flex;
}
.search__inner {
  position: relative;
  width: fit-content;
}
.search-list {
  background-color: #fff;
  position: absolute;
  z-index: 20;
  bottom: -7px;
  transform: translateY(100%);
  width: 100%;
  max-width: 100%;
  box-shadow: 0 0px 2px #495cab;
}
.search-list__item {
  padding: 10px;
  font-family: Montserrat;
  font-size: 18px;
  font-style: normal;
  font-weight: 400;
  line-height: normal;
  color: #272727;
  cursor: pointer;
  transition: 0.6s;
}
.search-list__item:hover {
  color: #fff;
  background-color: #495cab;
}
.active-item {
  color: #fff;
  background-color: #495cab;
}
@media (max-width: 500px) {
  .search,
  .search__inner {
    width: 100%;
  }
  .search {
    margin-bottom: 37px;
  }
}
</style>
